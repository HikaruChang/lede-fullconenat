From 878a528874476956307c2cc4dd0268960727a9b0 Mon Sep 17 00:00:00 2001
From: Syrone Wong <wong.syrone@gmail.com>
Date: Sun, 4 Jun 2023 11:48:54 +0800
Subject: [PATCH 1/2] Revert "Improved interoperability between the driver and
 the mac80211 layer in terms of encryption."

This reverts commit aaa264aa672bb1d53e88e4e6c2e17ade2f007581.
---
 core.h            |   5 ++
 debugfs.c         |   7 +++
 hif/fwcmd.c       | 126 +++++++++++++++++++++++++---------------------
 hif/pcie/dev.h    |  39 ++++++++++++++
 hif/pcie/tx.c     |  58 ++++++++++++++++-----
 hif/pcie/tx_ndp.c |  11 +---
 mac80211.c        |  29 ++++-------
 7 files changed, 176 insertions(+), 99 deletions(-)

diff --git a/core.h b/core.h
index a2ab884..cd74802 100644
--- a/core.h
+++ b/core.h
@@ -429,6 +429,9 @@ struct mwl_vif {
 	bool use_short_preamble;
 	int basic_rate_idx;
 	u8 broadcast_ssid;
+	u16 iv16;
+	u32 iv32;
+	s8 keyidx;
 };
 
 struct mwl_tx_info {
@@ -507,6 +510,8 @@ struct mwl_sta {
 	u16 rx_gi;
 	u16 rx_rate_mcs;
 	u8 rx_signal;
+	u16 iv16;
+	u32 iv32;
 };
 
 static inline struct mwl_vif *mwl_dev_get_vif(const struct ieee80211_vif *vif)
diff --git a/debugfs.c b/debugfs.c
index 19b8834..c8bda3d 100644
--- a/debugfs.c
+++ b/debugfs.c
@@ -539,6 +539,11 @@ static ssize_t mwl_debugfs_vif_read(struct file *file, char __user *ubuf,
 				 "true" : "false");
 		len += scnprintf(p + len, size - len,
 				 "use_short_preamble: %s\n", mwl_vif->use_short_preamble ? "enable" : "disable");
+		len += scnprintf(p + len, size - len,
+				 "key idx: %d\n", mwl_vif->keyidx);
+		len += scnprintf(p + len, size - len,
+				 "IV: %08x%04x\n", mwl_vif->iv32,
+				 mwl_vif->iv16);
 		beacon_info = &mwl_vif->beacon_info;
 		dump_data(p, size, &len, beacon_info->ie_wmm_ptr,
 			  beacon_info->ie_wmm_len, "WMM:");
@@ -631,6 +636,8 @@ static ssize_t mwl_debugfs_sta_read(struct file *file, char __user *ubuf,
 				 sta->tdls, sta->tdls_initiator);
 		len += scnprintf(p + len, size - len, "wme: %d, mfp: %d\n",
 				 sta->wme, sta->mfp);
+		len += scnprintf(p + len, size - len, "IV: %08x%04x\n",
+				 sta_info->iv32, sta_info->iv16);
 	}
 	spin_unlock_bh(&priv->sta_lock);
 
diff --git a/hif/fwcmd.c b/hif/fwcmd.c
index 076ec1b..61d39fd 100644
--- a/hif/fwcmd.c
+++ b/hif/fwcmd.c
@@ -821,6 +821,52 @@ static int mwl_fwcmd_set_country_code(struct mwl_priv *priv,
 	return 0;
 }
 
+static int mwl_fwcmd_encryption_set_cmd_info(struct hostcmd_cmd_set_key *cmd,
+					     u8 *addr,
+					     struct ieee80211_key_conf *key)
+{
+	cmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_UPDATE_ENCRYPTION);
+	cmd->cmd_hdr.len = cpu_to_le16(sizeof(*cmd));
+	cmd->key_param.length = cpu_to_le16(sizeof(*cmd) -
+		offsetof(struct hostcmd_cmd_set_key, key_param));
+	cmd->key_param.key_index = cpu_to_le32(key->keyidx);
+	cmd->key_param.key_len = cpu_to_le16(key->keylen);
+	ether_addr_copy(cmd->key_param.mac_addr, addr);
+
+	switch (key->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		cmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_WEP);
+		if (key->keyidx == 0)
+			cmd->key_param.key_info =
+				cpu_to_le32(ENCR_KEY_FLAG_WEP_TXKEY);
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		cmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_TKIP);
+		cmd->key_param.key_info =
+			(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?
+			cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE) :
+			cpu_to_le32(ENCR_KEY_FLAG_TXGROUPKEY);
+		cmd->key_param.key_info |=
+			cpu_to_le32(ENCR_KEY_FLAG_MICKEY_VALID |
+				      ENCR_KEY_FLAG_TSC_VALID);
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		cmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_AES);
+		cmd->key_param.key_info =
+			(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?
+			cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE) :
+			cpu_to_le32(ENCR_KEY_FLAG_TXGROUPKEY);
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		return 1;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
 static __le16 mwl_fwcmd_parse_cal_cfg(const u8 *src, size_t len, u8 *dst)
 {
 	const u8 *ptr;
@@ -2525,17 +2571,6 @@ int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
 	u32 action;
 	u8 idx;
 
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-	case WLAN_CIPHER_SUITE_TKIP:
-	case WLAN_CIPHER_SUITE_CCMP:
-		break;
-	default:
-		wiphy_err(hw->wiphy, "encryption not support\n");
-		return -ENOTSUPP;
-	}
-
 	mwl_vif = mwl_dev_get_vif(vif);
 
 	pcmd = (struct hostcmd_cmd_set_key *)&priv->pcmd_buf[0];
@@ -2547,17 +2582,19 @@ int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
 	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
 	pcmd->cmd_hdr.macid = mwl_vif->macid;
 
-	pcmd->key_param.length = cpu_to_le16(sizeof(*pcmd) - offsetof(struct hostcmd_cmd_set_key, key_param));
-	pcmd->key_param.key_index = cpu_to_le32(key->keyidx);
-	pcmd->key_param.key_len = cpu_to_le16(key->keylen);
-	ether_addr_copy(pcmd->key_param.mac_addr, addr);
+	rc = mwl_fwcmd_encryption_set_cmd_info(pcmd, addr, key);
+	if (rc) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		if (rc != 1)
+			wiphy_err(hw->wiphy, "encryption not support\n");
+		return rc;
+	}
 
 	idx = key->keyidx;
 
 	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
 		action = ENCR_ACTION_TYPE_SET_KEY;
 	else {
-		/* all done by software crypting */
 		action = ENCR_ACTION_TYPE_SET_GROUP_KEY;
 		if (vif->type == NL80211_IFTYPE_MESH_POINT &&
 		    !ether_addr_equal(mwl_vif->bssid, addr))
@@ -2568,9 +2605,6 @@ int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
 	switch (key->cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_WEP104:
-		pcmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_WEP);
-		if (key->keyidx == 0)
-			pcmd->key_param.key_info = cpu_to_le32(ENCR_KEY_FLAG_WEP_TXKEY);
 		if (!mwl_vif->wep_key_conf[idx].enabled) {
 			memcpy(mwl_vif->wep_key_conf[idx].key, key,
 			       sizeof(*key) + key->keylen);
@@ -2582,14 +2616,14 @@ int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
 		break;
 	case WLAN_CIPHER_SUITE_TKIP:
 		keymlen = MAX_ENCR_KEY_LENGTH + 2 * MIC_KEY_LENGTH;
-		pcmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_TKIP);
-		pcmd->key_param.key_info = cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE | ENCR_KEY_FLAG_MICKEY_VALID |ENCR_KEY_FLAG_TSC_VALID);
 		break;
 	case WLAN_CIPHER_SUITE_CCMP:
 		keymlen = key->keylen;
-		pcmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_AES);
-		pcmd->key_param.key_info = cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE);
 		break;
+	default:
+		mutex_unlock(&priv->fwcmd_mutex);
+		wiphy_err(hw->wiphy, "encryption not support\n");
+		return -ENOTSUPP;
 	}
 
 	memcpy((void *)&pcmd->key_param.key, key->key, keymlen);
@@ -2602,9 +2636,11 @@ int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
 
 	if (vif->type == NL80211_IFTYPE_STATION) {
 		if (ether_addr_equal(mwl_vif->bssid, addr))
-			ether_addr_copy(pcmd->key_param.mac_addr, mwl_vif->sta_mac);
+			ether_addr_copy(pcmd->key_param.mac_addr,
+					mwl_vif->sta_mac);
 		else
-			ether_addr_copy(pcmd->key_param.mac_addr, mwl_vif->bssid);
+			ether_addr_copy(pcmd->key_param.mac_addr,
+					mwl_vif->bssid);
 
 		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
 			mutex_unlock(&priv->fwcmd_mutex);
@@ -2626,17 +2662,6 @@ int mwl_fwcmd_encryption_remove_key(struct ieee80211_hw *hw,
 	struct hostcmd_cmd_set_key *pcmd;
 	int rc;
 
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-	case WLAN_CIPHER_SUITE_TKIP:
-	case WLAN_CIPHER_SUITE_CCMP:
-		break;
-	default:
-		wiphy_err(hw->wiphy, "encryption not support\n");
-		return -ENOTSUPP;
-	}
-
 	mwl_vif = mwl_dev_get_vif(vif);
 
 	pcmd = (struct hostcmd_cmd_set_key *)&priv->pcmd_buf[0];
@@ -2648,30 +2673,19 @@ int mwl_fwcmd_encryption_remove_key(struct ieee80211_hw *hw,
 	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
 	pcmd->cmd_hdr.macid = mwl_vif->macid;
 
-	pcmd->key_param.length = cpu_to_le16(sizeof(*pcmd) - offsetof(struct hostcmd_cmd_set_key, key_param));
-	pcmd->key_param.key_index = cpu_to_le32(key->keyidx);
-	pcmd->key_param.key_len = cpu_to_le16(key->keylen);
-	ether_addr_copy(pcmd->key_param.mac_addr, addr);
+	rc = mwl_fwcmd_encryption_set_cmd_info(pcmd, addr, key);
+	if (rc) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		if (rc != 1)
+			wiphy_err(hw->wiphy, "encryption not support\n");
+		return rc;
+	}
 
 	pcmd->action_type = cpu_to_le32(ENCR_ACTION_TYPE_REMOVE_KEY);
 
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		pcmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_WEP);
-		if (key->keyidx == 0)
-			pcmd->key_param.key_info = cpu_to_le32(ENCR_KEY_FLAG_WEP_TXKEY);
+	if (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
+	    key->cipher == WLAN_CIPHER_SUITE_WEP104)
 		mwl_vif->wep_key_conf[key->keyidx].enabled = 0;
-		break;
-	case WLAN_CIPHER_SUITE_TKIP:
-		pcmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_TKIP);
-		pcmd->key_param.key_info = cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE | ENCR_KEY_FLAG_MICKEY_VALID |ENCR_KEY_FLAG_TSC_VALID);
-		break;
-	case WLAN_CIPHER_SUITE_CCMP:
-		pcmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_AES);
-		pcmd->key_param.key_info = cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE);
-		break;
-	}
 
 	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
 		mutex_unlock(&priv->fwcmd_mutex);
diff --git a/hif/pcie/dev.h b/hif/pcie/dev.h
index 9d80212..5f61137 100644
--- a/hif/pcie/dev.h
+++ b/hif/pcie/dev.h
@@ -784,6 +784,45 @@ static inline void pcie_tx_add_dma_header(struct mwl_priv *priv,
 		cpu_to_le16(skb->len - dma_hdrlen + tail_pad);
 }
 
+static inline void pcie_tx_encapsulate_frame(struct mwl_priv *priv,
+					     struct sk_buff *skb,
+					     struct ieee80211_key_conf *k_conf,
+					     bool *ccmp)
+{
+	int head_pad = 0;
+	int data_pad = 0;
+
+	/* Make sure the packet header is in the DMA header format (4-address
+	 * without QoS), and add head & tail padding when HW crypto is enabled.
+	 *
+	 * We have the following trailer padding requirements:
+	 * - WEP: 4 trailer bytes (ICV)
+	 * - TKIP: 12 trailer bytes (8 MIC + 4 ICV)
+	 * - CCMP: 8 trailer bytes (MIC)
+	 */
+
+	if (k_conf) {
+		head_pad = k_conf->iv_len;
+
+		switch (k_conf->cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			data_pad = 4;
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			data_pad = 12;
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			data_pad = 8;
+			if (ccmp)
+				*ccmp = true;
+			break;
+		}
+	}
+
+	pcie_tx_add_dma_header(priv, skb, head_pad, data_pad);
+}
+
 static inline void pcie_tx_prepare_info(struct mwl_priv *priv, u32 rate,
 					struct ieee80211_tx_info *info)
 {
diff --git a/hif/pcie/tx.c b/hif/pcie/tx.c
index c89cbeb..e99fa7b 100644
--- a/hif/pcie/tx.c
+++ b/hif/pcie/tx.c
@@ -34,6 +34,21 @@
 #define TOTAL_AMPDU_QUEUES     (IEEE80211_NUM_ACS + \
 				PCIE_AMPDU_QUEUES)
 
+#define EXT_IV                             0x20
+#define INCREASE_IV(iv16, iv32) \
+{ \
+	(iv16)++; \
+	if ((iv16) == 0) \
+		(iv32)++; \
+}
+
+struct ccmp_hdr {
+	__le16 iv16;
+	u8 rsvd;
+	u8 key_id;
+	__le32 iv32;
+} __packed;
+
 static int pcie_tx_ring_alloc(struct mwl_priv *priv)
 {
 	struct pcie_priv *pcie_priv = priv->hif.priv;
@@ -282,6 +297,17 @@ static void pcie_txbd_ring_delete(struct mwl_priv *priv)
 	pcie_priv->txbd_ring_pbase = 0;
 }
 
+static inline void pcie_tx_add_ccmp_hdr(u8 *pccmp_hdr,
+					u8 key_id, u16 iv16, u32 iv32)
+{
+	struct ccmp_hdr *ccmp_h = (struct ccmp_hdr *)pccmp_hdr;
+
+	ccmp_h->iv16 = cpu_to_le16(iv16);
+	ccmp_h->rsvd = 0;
+	ccmp_h->key_id = EXT_IV | (key_id << 6);
+	ccmp_h->iv32 = cpu_to_le32(iv32);
+}
+
 static inline bool pcie_tx_available(struct mwl_priv *priv, int desc_num)
 {
 	struct pcie_priv *pcie_priv = priv->hif.priv;
@@ -325,8 +351,6 @@ static inline void pcie_tx_skb(struct mwl_priv *priv, int desc_num,
 	struct pcie_dma_data *dma_data;
 	struct ieee80211_hdr *wh;
 	dma_addr_t dma;
-	int tailpad = 0;
-	struct ieee80211_key_conf * k_conf;
 
 	if (WARN_ON(!tx_skb))
 		return;
@@ -336,17 +360,8 @@ static inline void pcie_tx_skb(struct mwl_priv *priv, int desc_num,
 	sta = (struct ieee80211_sta *)tx_ctrl->sta;
 	vif = (struct ieee80211_vif *)tx_info->control.vif;
 	mwl_vif = mwl_dev_get_vif(vif);
-	k_conf = (struct ieee80211_key_conf *)tx_info->control.hw_key;
-
-	if (k_conf) {
-		switch (k_conf->cipher) {
-		case WLAN_CIPHER_SUITE_WEP40:
-		case WLAN_CIPHER_SUITE_WEP104: tailpad = 4; break;
-		case WLAN_CIPHER_SUITE_TKIP:   tailpad = 12;break;
-		case WLAN_CIPHER_SUITE_CCMP:   tailpad = 8; break;
-		}
-	}
-	pcie_tx_add_dma_header(priv, tx_skb, 0, tailpad);
+
+	pcie_tx_encapsulate_frame(priv, tx_skb, (struct ieee80211_key_conf *)tx_info->control.hw_key, &ccmp);
 
 	if (priv->chip_type == MWL8997) {
 		pfu_dma_data = (struct pcie_pfu_dma_data *)tx_skb->data;
@@ -365,6 +380,23 @@ static inline void pcie_tx_skb(struct mwl_priv *priv, int desc_num,
 		wiphy_info(priv->hw->wiphy,
 			  "Probe Resp: %pM\n", wh->addr1);
 
+	if(utils_is_crypted(wh)) {
+		if(ccmp) {
+			if (is_multicast_ether_addr(ieee80211_get_DA(wh)) ||
+			    vif->type == NL80211_IFTYPE_STATION) {
+				pcie_tx_add_ccmp_hdr(dma_data->data, mwl_vif->keyidx, mwl_vif->iv16, mwl_vif->iv32);
+				INCREASE_IV(mwl_vif->iv16, mwl_vif->iv32);
+			} else {
+				struct mwl_sta *sta_info;
+
+				sta_info = mwl_dev_get_sta(sta);
+
+				pcie_tx_add_ccmp_hdr(dma_data->data, 0, sta_info->iv16, sta_info->iv32);
+				INCREASE_IV(sta_info->iv16, sta_info->iv32);
+			}
+		}
+	}
+
 	if (tx_info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)
 		tx_desc->flags |= PCIE_TX_WCB_FLAGS_DONT_ENCRYPT;
 	if (tx_info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)
diff --git a/hif/pcie/tx_ndp.c b/hif/pcie/tx_ndp.c
index 9cf5ba9..ad58ac4 100644
--- a/hif/pcie/tx_ndp.c
+++ b/hif/pcie/tx_ndp.c
@@ -506,7 +506,6 @@ void pcie_tx_xmit_ndp(struct ieee80211_hw *hw,
 	u8 *da;
 	u16 qos;
 	u8 tid = 0;
-	int tailpad = 0;
 	struct mwl_ampdu_stream *stream = NULL;
 	u16 tx_que_priority;
 	bool mgmtframe = false;
@@ -592,15 +591,7 @@ void pcie_tx_xmit_ndp(struct ieee80211_hw *hw,
 			ieee80211_tx_status(hw, ack_skb);
 		}
 
-		if (k_conf) {
-			switch (k_conf->cipher) {
-			case WLAN_CIPHER_SUITE_WEP40:
-			case WLAN_CIPHER_SUITE_WEP104: tailpad = 4; break;
-			case WLAN_CIPHER_SUITE_TKIP:   tailpad = 12;break;
-			case WLAN_CIPHER_SUITE_CCMP:   tailpad = 8; break;
-			}
-		}
-		pcie_tx_add_dma_header(priv, skb, 0, tailpad);
+		pcie_tx_encapsulate_frame(priv, skb, k_conf, NULL);
 	} else {
 		tid = qos & 0x7;
 		if (sta && sta->ht_cap.ht_supported && !eapol_frame &&
diff --git a/mac80211.c b/mac80211.c
index 571c402..8da9e49 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -224,6 +224,9 @@ static int mwl_mac80211_add_interface(struct ieee80211_hw *hw,
 	mwl_vif->use_short_preamble = false;
 	mwl_vif->basic_rate_idx = 0;
 	mwl_vif->broadcast_ssid = 0xFF;
+	mwl_vif->iv16 = 1;
+	mwl_vif->iv32 = 0;
+	mwl_vif->keyidx = 0;
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_AP:
@@ -631,21 +634,6 @@ static int mwl_mac80211_set_key(struct ieee80211_hw *hw,
 	u8 encr_type;
 	u8 *addr;
 
-	/*
-	 * While the hardware supports *catch-all* key, for offloading
-	 * group-key en-/de-cryption. The way of how the hardware
-	 * decides which keyId maps to which key, remains a mystery...
-	 */
-	if ((key->flags & IEEE80211_KEY_FLAG_PAIRWISE) == 0)
-		return 1;
-
-	/* this one needs to be done in software */
-	if (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||
-	    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||
-	    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256 ||
-	    key->cipher == WLAN_CIPHER_SUITE_BIP_CMAC_256)
-		return 1;
-
 	mwl_vif = mwl_dev_get_vif(vif);
 	addr = sta ? sta->addr : vif->addr;
 
@@ -655,16 +643,15 @@ static int mwl_mac80211_set_key(struct ieee80211_hw *hw,
 			encr_type = ENCR_TYPE_WEP;
 		} else if (key->cipher == WLAN_CIPHER_SUITE_CCMP) {
 			encr_type = ENCR_TYPE_AES;
-			key->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;
-			key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+			if ((key->flags & IEEE80211_KEY_FLAG_PAIRWISE) == 0) {
+				if (vif->type != NL80211_IFTYPE_STATION)
+					mwl_vif->keyidx = key->keyidx;
+			}
 		} else if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {
-			key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;
-			key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
 			encr_type = ENCR_TYPE_TKIP;
 		} else {
 			encr_type = ENCR_TYPE_DISABLE;
 		}
-		key->hw_key_idx = key->keyidx;
 
 		rc = mwl_fwcmd_update_encryption_enable(hw, vif, addr,
 							encr_type);
@@ -748,6 +735,8 @@ static int mwl_mac80211_sta_add(struct ieee80211_hw *hw,
 	if (vif->type == NL80211_IFTYPE_STATION)
 		sta_info->sta_stnid = sta_stnid;
 	sta_info->tx_rate_info = utils_get_init_tx_rate(priv, &hw->conf, sta);
+	sta_info->iv16 = 1;
+	sta_info->iv32 = 0;
 	spin_lock_init(&sta_info->amsdu_lock);
 	spin_lock_bh(&priv->sta_lock);
 	list_add_tail(&sta_info->list, &priv->sta_list);
-- 
2.41.0

