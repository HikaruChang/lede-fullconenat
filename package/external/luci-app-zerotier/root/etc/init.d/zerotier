#!/bin/sh /etc/rc.common

START=90

USE_PROCD=1

PROG=/usr/bin/zerotier-one
GENERATED_CONFIG_PATH=/var/lib/zerotier-one

section_enabled() {
	config_get_bool enabled "$1" 'enabled' 0
	[ $enabled -ne 0 ]
}

start_instance() {
	local cfg="$1"
	local public_portion port secret config_path local_conf copy_config_path generated_cfg_path
	local args=""

	if ! section_enabled "$cfg"; then
		echo "zerotier init: $cfg: disabled in config"
		return 1
	fi

	config_get config_path $cfg 'config_path'
	config_get port $cfg 'port'
	config_get secret $cfg 'secret'
	config_get public_portion $cfg 'public_portion'
	config_get local_conf $cfg 'local_conf'
	config_get_bool copy_config_path $cfg 'copy_config_path' 0

	generated_cfg_path=${GENERATED_CONFIG_PATH}_$cfg

	# Remove existing link or folder
	rm -rf $generated_cfg_path

	# Create link or copy files from GENERATED_CONFIG_PATH to config_path
	if [ -n "$config_path" ] && [ "$config_path" != "$generated_cfg_path" ]; then
		if [ ! -d "$config_path" ]; then
			echo "ZeroTier config_path does not exist: $config_path" 1>&2
			return
		fi

		# ensure that the target exists
		mkdir -p $(dirname $generated_cfg_path)

		if [ x"$copy_config_path" = x"1" ]; then
			cp -r $config_path $generated_cfg_path
		else
			ln -s $config_path $generated_cfg_path
		fi
	fi

	[ -d $generated_cfg_path/networks.d ] || mkdir -p $generated_cfg_path/networks.d
	[ -d $generated_cfg_path/peers.d ] || mkdir -p $generated_cfg_path/peers.d
	[ -d $generated_cfg_path/moons.d ] || mkdir -p $generated_cfg_path/moons.d

	# link latest default config generated_cfg_path to latest config generated_cfg_path
	rm -f $GENERATED_CONFIG_PATH
	ln -s $generated_cfg_path $GENERATED_CONFIG_PATH

	if [ -n "$port" ]; then
		args="$args -p${port}"
	fi

	old_secret=$(cat $generated_cfg_path/identity.secret)
	if [ -n "$old_secret" ]; then
		echo "found old secret on $generated_cfg_path"
		uci set zerotier.$cfg.secret="$old_secret"
		uci commit zerotier
		# read secret again
		config_get secret $cfg 'secret'
		# extract public from private secret
		zerotier-idtool getpublic $generated_cfg_path/identity.secret > $generated_cfg_path/identity.public
		public="$(cat $generated_cfg_path/identity.public)"
		uci set zerotier.$cfg.public_portion="$public"
		uci commit zerotier
		# read public_portion again
		config_get public_portion $cfg 'public_portion'
	fi

	if [ -z "$secret" ]; then
		echo "Generate secret - please wait..."
		local sf="/tmp/zt.$cfg.secret"

		zerotier-idtool generate "$sf" > /dev/null
		[ $? -ne 0 ] && return 1

		secret="$(cat $sf)"
		rm "$sf"

		uci set zerotier.$cfg.secret="$secret"
		uci commit zerotier
	fi

	if [ -n "$secret" ] && [ x"$old_secret" != x"$secret" ]; then
		echo "old_secret and uci secret differ, saving to $generated_cfg_path"
		echo "$secret" > $generated_cfg_path/identity.secret
		# make sure there is not previous identity.public
		rm -f $generated_cfg_path/identity.public
		# extract public from private secret
		zerotier-idtool getpublic $generated_cfg_path/identity.secret > $generated_cfg_path/identity.public
		public="$(cat $generated_cfg_path/identity.public)"
		uci set zerotier.$cfg.public_portion="$public"
		uci commit zerotier
	fi

	if [ -f "$local_conf" ]; then
		ln -s "$local_conf" $generated_cfg_path/local.conf
	fi

	add_join() {
		# an (empty) config file will cause ZT to join a network
		touch $generated_cfg_path/networks.d/$1.conf
	}

	config_list_foreach $cfg 'join' add_join

	procd_open_instance
	procd_set_param command $PROG $args $GENERATED_CONFIG_PATH
	procd_set_param stderr 1
	procd_set_param respawn
	procd_close_instance
}

start_service() {
	config_load 'zerotier'
	config_foreach start_instance 'zerotier'
}

stop_instance() {
	local cfg="$1"
	#BUG: zerotier have to write to peers.d/* and should NOT remove these files
	# Remove existing link or folder
	#rm -rf ${GENERATED_CONFIG_PATH}_${cfg}
}

stop_service() {
	config_load 'zerotier'
	config_foreach stop_instance 'zerotier'
	#BUG: zerotier have to write to peers.d/* and should NOT remove these files
	#rm -f ${GENERATED_CONFIG_PATH}
}

reload_service() {
	stop
	start
}

service_triggers() {
	procd_add_reload_trigger 'zerotier'
}
